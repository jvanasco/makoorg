
<html>

<head>

<style>
        body {
            font-family:arial,helvetica;
        }
</style>

</head>

<body>


<h1>Mako Templates for Python</h1>

<h2>Slogan</h2>
<p>Hyperfast and Lightweight Templating for the Python Platform
</p>

<h2>Features</h2>
<ul>
 <li><p>Python Server Pages.  Templates compile into Python modules for maximum performance.
   <li> <p>Insanely Fast.  An included bench suite, adapted from a suite included with Genshi, has these results for a simple three-sectioned layout:</p>
   <table>
   <tr><td>Mako:</td><td>0.51 ms</td></tr>
   <tr><td>Cheetah:</td><td>0.80 ms</td></tr>
   <tr><td>Django:</td><td>5.43 ms</td></tr>
   <tr><td>Myghty:</td><td>5.25 ms</td></tr>
   <tr><td>Genshi:</td><td>12.53 ms</td></tr>
   <tr><td>Kid:</td><td>19.12 ms</td></tr>
   </table>
   </li>
</p>

 </li>

 <li><p>Super-simple API.  For basic usage, just one class, <code>Template</code> is needed:
</p>
<pre><code>from mako.template import Template
print Template(&quot;hello ${data}!&quot;).render(data=&quot;world&quot;)
</code></pre>
 </li>

 <li><p>To manage many templates, leveraging industrial strength module generation and management code adapted from Myghty, use the <code>TemplateLookup</code> class:
</p>
<pre><code>from mako.lookup import TemplateLookup
lookup = TemplateLookup(directories=['/my/htmlfiles'])
template = lookup.get_template('index.html')
print template.render(data=&quot;foo&quot;)
</code></pre>
 </li>

 <li><p>Mako's syntax borrows from the best ideas of many others, including:
</p>
<ul>
 <li>
     Django Templates
 </li>

 <li>
     Myghty / Mason
 </li>

 <li>
     Cheetah
 </li>

 <li>
     Genshi
 </li>

 <li>
     Java Server Pages
 </li>

 <li>
     Struts Tiles
 </li>
</ul>

 </li>

 <li><p>Standard template features:
</p>
<ul>
 <li><p>control structures
</p>
<pre><code>% if len(v) &gt; 5:
    % for x in range(1,5):
        hi ${x}
    % endfor
% endif
</code></pre>
 </li>

 <li><p>straight python code:
</p>
<pre><code>&lt;%
    data = handle.lookup()
    view = [d.name for d in data]
%&gt;
</code></pre>
 </li>

 <li><p>callable blocks, with or without arguments, which also pull names from the enclosing scope:
</p>
<pre><code># define:
&lt;%component name=&quot;foo(x, y)&quot;&gt;
    hi im foo ${x} ${y} ${z}
&lt;/%component&gt;

# then call:
${foo(4,5)}
</code></pre>
 </li>

 <li><p>multi-zoned page inheritance
</p>

 </li>

 <li><p>&quot;component-calls-with-content&quot; - call any def, nesting any number locally-defined blocks of text as arguments.  This is the basis for creating custom tags:
</p>
<pre><code># define:
&lt;%component name=&quot;foo(x, y)&quot;&gt;
    ${head()}
    foo ${x} {$y}
    ${body()}
&lt;/%component&gt;

# then call, defining two more blocks
&lt;%call expr=&quot;foo(3, 4)&quot;&gt;
    &lt;%component name=&quot;head&quot;&gt;
        the header
    &lt;/%component&gt;
    main body
&lt;/%call&gt;
</code></pre>
 </li>

 <li><p>filters, either the standard builtins or custom functions, applicable to any expression or <code>&lt;%component&gt;</code> definition:
</p>
<pre><code>${&quot;some text&quot; | h}

&lt;%component name=&quot;foo&quot; filter=&quot;filter1, x&quot;&gt;
    ...
&lt;/%component&gt;
</code></pre>
 </li>

 <li><p>custom tags can be created as templated components, or Python modules containing callables.  Whole sets of custom tags can be imported into the current template's namespace using the <code>&lt;%namespace&gt;</code> tag.
</p>

 </li>

 <li><p>caching built in from the ground up.  any template or block of text within can be cached using memory, file, DBM or memcached backends.
</p>

 </li>
</ul>

 </li>
</ul>

<h2>Language</h2>

<h3>Control Structures</h3>
<p>Control structures use the % operator.  % can start anywhere on the line, preceded by only whitespace.  Blocks are terminated by name-qualified terminators.  <br />
</p>
<pre><code>% for item in items: 
    % if foo:
    ${item}
    some text
    % endif
% endfor
</code></pre><p>The amount of whitespace before the % and after the % before the code starts is not significant.
</p>
<p>Myghty style:
</p>
<pre><code>% if x:
%   if y:
%   endif
% endif
</code></pre><p>&quot;Cheetah&quot; style:
</p>
<pre><code>%if x:
    %if y:
    %endif
%endif
</code></pre><p>Messy style (you probably wouldn't want to code this way for readablity):
</p>
<pre><code>  %if x:
    %if y:
    % endif
      %      endif
</code></pre>
<h3>Comments</h3>
<p>Work similarly to %, using the # tag:
</p>
<pre><code>&lt;html&gt;
    # this is a comment.
&lt;/html&gt;
</code></pre>
<h3>Truncating Newlines</h3>
<p>End any line with a backslash (\) to suppress the newline at the end:
</p>
<pre><code>% for x in [1,2,3]:\
    ${x} \
% endfor
</code></pre><p>Produces the output:
</p>
<pre><code>1 2 3
</code></pre><p>The newline truncator is particularly important for producing plaintext documents such as emails, as well as preformatted sections of HTML (i.e. using <code>&lt;pre&gt;</code>).
</p>

<h3>Expressions</h3>
<p>Expressions usually use ${expr} syntax, and compile into literal Python.
</p>
<pre><code>${someexpression}

${&quot;foo&quot; + &quot;bar&quot;}
</code></pre>
<h3>Variable Namespace</h3>
<p>A template executes with a single contextual dictionary.  This dictionary is completely transparent in the template itself.  AST parsing of all embedded Python is performed in order to locate all referenced variable names, which are pre-declared from the dictionary at runtime (or None if not present) before template-generated Python is executed.  So when a variable &quot;x&quot; is referenced, the searched hierarchy is:
</p>
<ul>
 <li>
     Variables declared within control structures or locally embedded python code
 </li>

 <li>
     Variables explicitly declared by the page or component
 </li>

 <li>
     Variables declared in the template at the module-level
 </li>

 <li>
     Components (callables) and namespaces (groups of callables) declared within the template
 </li>

 <li>
     Variables passed to component calls, undeclared by the component or page
 </li>

 <li>
     Variables passed to the template's context, undeclared by the component or page
 </li>
</ul>
<p>If you need to get at the context directly (such as if youve declared a module-level variable thats overriding a name), its available as <code>context</code>, and it follows dictionary conventions:
</p>
<pre><code>the context:  ${context['some key']}
</code></pre><p>Other names that are sometimes used by default include <code>body</code>, within a component call, and <code>text</code>, within a filter call.
</p>

<h3>Embedding Python</h3>

<h4>Inline</h4>
<p>Inline Python is embedded via the &lt;% %&gt; tags.  This is straight python so the whitespace is significant.  You can emit text via the <code>write()</code> method on the context.
</p>
<pre><code>&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;some table&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;
    &lt;%
        for x in [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]:
            context.write(&quot;&lt;td&gt;%s&lt;/td&gt;&quot; % x)
    %&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre><p>Remember that you can reference any variable name from the template's context, and it will be pulled from the context automatically.  This works similarly to a global variable in Python; i.e. if you assign to the variable name first, then its a local variable.
</p>
<p>Context:
</p>
<pre><code>{'x':'one', 'y':'two'}
</code></pre><p>Template:
</p>
<pre><code>&lt;% 
    context.write(&quot;X is &quot; + x + &quot;\n&quot;)
    y = &quot;hi there&quot;
    context.write(&quot;Y is &quot; + y + &quot;\n&quot;)
%&gt;
</code></pre><p>Produces:
</p>
<pre><code>X is one
Y is hi there
</code></pre>
<h4>Module Level</h4>
<p>Module level Python is declared by the &lt;%! %&gt; tags.  Python in these blocks occurs at module import time (i.e. global scope)
</p>
<pre><code>&lt;%!
    import mystuff
    def writefoo(text):
        return &quot;foo is &quot; +text
%&gt;

hello ${writefoo('jack')}
</code></pre><pre><code>
</code></pre>
<h3>File Includes</h3>
<p>Use the &lt;%include&gt; tag.
</p>
<pre><code>&lt;%include file=&quot;somefile.txt&quot;/&gt;
</code></pre><p>This tag also can handle expressions:
</p>
<pre><code>&lt;%include file=&quot;${filename}&quot;/&gt;
</code></pre><p>In fact every &lt;%tag&gt; can use expressions (i.e. ${}) inside of their quoted sections.
</p>
<p>The include tag requires that the template being called has a <code>TemplateLookup</code> available with which to locate the included template.
</p>
<p>Add the <code>import=&quot;true&quot;</code> flag to the <code>&lt;%include&gt;</code> tag and when you include the file, all the <code>&lt;%component&gt;</code> and <code>&lt;%namespace&gt;</code> sections declared in that file (described later) are pulled into the local namespace of the template, as though they were declared locally:
</p>
<pre><code>&lt;%include file=&quot;somefile.html&quot; import=&quot;true&quot;/&gt;
</code></pre>
<h3>Components</h3>
<p>The component is the single tag used to demarcate any block of text and/or code.  It exists within generated Python as a callable function. 
</p>
<pre><code>&lt;%component name=&quot;hello&quot;&gt;
    hello world
&lt;/%component&gt;
</code></pre><p>They are normally called as expressions.
</p>
<pre><code>the component:  ${hello()}
</code></pre><p>A <code>&lt;%component&gt;</code> can be declared anywhere inside a template, and becomes available throughout the template, including above where it was declared.  The callable generated by <code>&lt;%component&gt;</code> gets generated outside of the enclosing template's callable.  The name of the callable is then placed in the variable namespace of the parent component.
</p>
<p>Components have access to the current contextual namespace in exactly the same way their parent template does.  <br />
</p>
<pre><code>Hello there ${username}, how are ya.  Lets see what your account says:

${account()}

&lt;%component name=&quot;account&quot;&gt;
    Account for ${username}:&lt;br/&gt;

    % for row in accountdata:
        Value: ${row}&lt;br/&gt;
    % endfor
&lt;/%component&gt;
</code></pre><p>You can also pass arguments to a component, which show up in the component's variable namespace overriding whatever is in the enclosing namespace:
</p>
<pre><code>${account(name='john')}

&lt;%component name=&quot;account&quot;&gt;
    Hi ${name}
&lt;/%component&gt;
</code></pre><p>If you want your component to have positional arguments, you can declare them:
</p>
<pre><code>&lt;%component name=&quot;account(accountname, type)&quot;&gt;
    account name: ${accountname}, type ${type}
&lt;/%component&gt;
</code></pre><p>As well as keyword arguments explicitly declared, using normal Python conventions:
</p>
<pre><code>&lt;%component name=&quot;account(accountname, type='personal')&quot;&gt;
    account name: ${accountname}, type ${type}
&lt;/%component&gt;
</code></pre><p>When you declare explicit arguments in your component signature, they are required following normal Python conventions.  This is in contrast to using variable names implicitly from the template's context, which produces <code>None</code> if the name doesn't exist.  Additionally, explicitly declared arguments are handy in case you have the same names declared at the module level, and you'd like to insure that you get those arguments from the component call itself.
</p>

<h4>Calling Components from Other Files</h4>
<p>Calling a component from another file differs from a regular <code>&lt;%include&gt;</code>, in that you are calling a specific component declared in that template, not the template body itself.
</p>
<p>First, load the file you want into a &quot;namespace&quot;:
</p>
<pre><code>&lt;%namespace name=&quot;mystuff&quot; file=&quot;mystuff.html&quot;/&gt;
</code></pre><p>The namespace tag is declared once per template, and adds a local variable &quot;mystuff&quot; to the current scope.
</p>
<p>Then, just call the components off of <code>mystuff</code>:
</p>
<pre><code>${mystuff.somecomponent(x=5,y=7)}
</code></pre>
<h4>Components within Components</h4>
<p>The component model is totally recursive.  Declaring <code>&lt;%component&gt;</code> inside another <code>&lt;%component&gt;</code> leads it to be local to its parent:
</p>
<pre><code>&lt;%component name=&quot;mycomponent&quot;&gt;
    &lt;%component name=&quot;subcomponent&quot;&gt;
        a sub component
    &lt;/%component&gt;

    im the component, and the subcomopnent is ${subcomponent()}
&lt;/%component&gt;
</code></pre><p>The recursive component model becomes very handy for doing layouts, including usage within inheriting templates.
</p>

<h4>Calling a component with embedded content and/or other components</h4>
<p>A flip-side to component within component is a component call with content.  This is where you call a component, and at the same time declare a block of content that can be used by the component being called.  This is the basic method used to declare &quot;custom tags&quot;.   To achieve this, use the <code>&lt;%call&gt;</code> tag instead of the regular expression syntax.  By default, the body of content is assigned to the name <code>body</code>:
</p>
<pre><code>&lt;%component name=&quot;buildtable&quot;&gt;
    &lt;table&gt;
        &lt;tr&gt;&lt;td&gt;
            ${body()}
        &lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;
&lt;/%component&gt;

&lt;%call expr=&quot;buildtable&quot;&gt;
    I am the table body.
&lt;/%call&gt;
</code></pre><p>This produces the output:
</p>
<pre><code>&lt;table&gt;
    &lt;tr&gt;&lt;td&gt;
        I am the table body.
    &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre><p>The <code>body</code> name is executed each time its referenced.  This means you can use component-call-with-content to build iterators, conditionals, etc:
</p>
<pre><code>&lt;%component name=&quot;lister(count)&quot;&gt;
    % for x in range(1,count):
        ${body()}
    % endfor
&lt;/%component&gt;

&lt;%call expr=&quot;lister(3)&quot;&gt;
    hi
&lt;/%call&gt;
</code></pre><p>Produces:
</p>
<pre><code>hi
hi
hi
</code></pre><p>A custom &quot;conditional&quot; tag:
</p>
<pre><code>&lt;%component name=&quot;conditional(expr)&quot;&gt;
    % if expr:
        ${body()}
    %
&lt;/%component&gt;

&lt;%call expr=&quot;conditional(4==4)&quot;&gt;
    im the result
&lt;/%call&gt;
</code></pre><p>Produces:
</p>
<pre><code>im the result
</code></pre><p>Since <code>body</code> is a callable, the hosting component can pass arguments:
</p>
<pre><code>&lt;%component name=&quot;layoutdata(somedata)&quot;&gt;
    &lt;table&gt;
    % for item in somedata:
        &lt;tr&gt;
        % for col in item:
            &lt;td&gt;${body(col=col)}&lt;/td&gt;\
        % endfor
        &lt;/tr&gt;
    % endfor
    &lt;/table&gt;
&lt;/%component&gt;

&lt;%call expr=&quot;layoutdata([[1,2,3],[4,5,6],[7,8,9]])&quot;&gt;
    Body data: ${col}
&lt;/%call&gt;
</code></pre><p>Produces:
</p>
<pre><code>&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;Body data: 1&lt;/td&gt;&lt;td&gt;Body data: 2&lt;/td&gt;&lt;td&gt;Body data: 3&lt;/td&gt;
        &lt;td&gt;Body data: 2&lt;/td&gt;&lt;td&gt;Body data: 5&lt;/td&gt;&lt;td&gt;Body data: 6&lt;/td&gt;
        &lt;td&gt;Body data: 3&lt;/td&gt;&lt;td&gt;Body data: 8&lt;/td&gt;&lt;td&gt;Body data: 9&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre><p>If you combine nested components with the component call with content, you can build whole layouts quite easily:
</p>
<pre><code>&lt;%component name=&quot;layout&quot;&gt;
    # a layout component
    &lt;div class=&quot;mainlayout&quot;&gt;
        &lt;div class=&quot;header&quot;&gt;
            ${header()}
        &lt;/div&gt;
        &lt;div class=&quot;sidebar&quot;&gt;
            ${sidebar()}
        &lt;/div&gt;
        &lt;div class=&quot;content&quot;&gt;
            ${body()}
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/%component&gt;

# calls the layout component
&lt;%call expr=&quot;layout&quot;&gt;
    &lt;%component name=&quot;header&quot;&gt;
        I am the header
    &lt;/%component&gt;
    &lt;%component name=&quot;sidebar&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;sidebar 1&lt;/li&gt;
            &lt;li&gt;sidebar 2&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/%component&gt;

        this is the body
&lt;/%call&gt;
</code></pre><p>The above layout would produce:
</p>
<pre><code>&lt;div class=&quot;mainlayout&quot;&gt;
    &lt;div class=&quot;header&quot;&gt;
        I am the header
    &lt;/div&gt;
    &lt;div class=&quot;sidebar&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;sidebar 1&lt;/li&gt;
            &lt;li&gt;sidebar 2&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div class=&quot;content&quot;&gt;
        this is the body
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3>Inheritance</h3>
<p>Inheritance allows you to specify another template file that should take control of execution, using the current template's namespace.  This is provided via the &lt;%inherit&gt; tag.  This works similarly to the component call with content example above, where <code>body</code> is the main body of the template and you can also define other <code>&lt;%component&gt;</code> sections:
</p>
<pre><code># page.html:

&lt;%inherit name=&quot;base.html&quot;/&gt;
&lt;%component name=&quot;header&quot;&gt;
    this is the header
&lt;/%component&gt;

I am the body

&lt;%component name=&quot;footer&quot;&gt;
    this is the footer
&lt;/%component&gt;

# base.html:

&lt;html&gt;
    &lt;body&gt;
        &lt;div class=&quot;top&quot;&gt;
            ${header()}
        &lt;/div&gt;

        ${body()}

        ${footer()}
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>Which produces:
</p>
<pre><code>&lt;html&gt;
    &lt;body&gt;
        &lt;div class=&quot;top&quot;&gt;
            this is the header
        &lt;/div&gt;

        I am the body

        this is the footer
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>The inheritance of the parent template occurs <em>where you put the inherit tag.</em>  This means whatever content is above the inherit tag gets executed normally, without any inheritance.  It also means you can inherit <em>dynamically!</em>
</p>
<pre><code>&lt;%
    if layout=='green':
        inheritfrom = 'greentmpl.html'
    else:
        inheritfrom = 'normaltmpl.html'
%&gt;
&lt;%inherit name=&quot;${inheritfrom}&quot;/&gt;
</code></pre>
<h3>Page-level arguments</h3>
<p>As components can declare optinally explicit argument signatures, so can your template, using the <code>&lt;%page&gt;</code> tag:
</p>
<pre><code>&lt;%page arguments=&quot;(arg1, arg2, arg3=None)&quot;/&gt;
</code></pre><p>The named arguments are pulled from the incoming context dictionary, overriding any module-level declared arguments.  It also serves as a way to declare certain context arguments as required.
</p>

<h3>Filters</h3>
<p>Filters are callable functions that receive a single textual argument as a string, and return a new textual string as output.  They are called using the <code>|</code> operator in expressions:
</p>
<pre><code>${&quot;this is some text&quot; | html}
</code></pre><p>Or using the <code>filter</code> keyword for a <code>&lt;%component&gt;</code> or <code>&lt;%call&gt;</code> directive:
</p>
<pre><code>&lt;%component name=&quot;mycomp&quot; filter=&quot;html&quot;&gt;
&lt;/%component&gt;
</code></pre><p>Standard built-in filters are included: <code>html</code>, <code>xml</code>, <code>url</code>.
</p>
<p>Creating your own filters is easy.  Any callable that is in the template's namespace can be used, or you can declare functions:
</p>
<pre><code>&lt;%|
    def myfilter(text):
        return &quot;text&quot; + text + &quot;filtered&quot;
%&gt;

    ${&quot;hiya&quot; | myfilter}
</code></pre><p>Filters can also be defined using the <code>&lt;%component&gt;</code> tag.   The text to be filtered is placed into the name 'text':
</p>
<pre><code>&lt;%component myfilter&gt;
    text${text}filtered
&lt;/%component&gt;

${&quot;hiya&quot; | myfilter}
</code></pre><p>Filters can take arguments !  Using a python function:
</p>
<pre><code>&lt;%|
    def pythonfilter(text, arg1, arg2='foo'):
        return &quot;text&quot; + text + &quot;filtered&quot;
%&gt;
${&quot;hiya&quot; | pythonfilter('hello', 'world')}
</code></pre><p>Or a <code>&lt;%component&gt;</code>:
</p>
<pre><code>&lt;%component componentfilter(arg1, arg2='foo')&gt;
    text${text}filtered
&lt;/%component&gt;

${&quot;hiya&quot; | componentfilter('hello', 'world')}
</code></pre>
<h3>Caching</h3>
<p>Any template or component can be cached using the <code>cache</code> argument to the <code>%page</code> or <code>%component</code> directives:
</p>
<pre><code>&lt;%page cache=&quot;true&quot;/&gt;

    template text

&lt;%component name=&quot;mycomp&quot; cache=&quot;true&quot; cache_timeout=&quot;30&quot; cache_type=&quot;memory&quot;&gt;
    other text
&lt;/%component&gt;
</code></pre><p>Cache arguments:
   - cache=&quot;false|true&quot; - turn caching on
   - cache_timeout - number of seconds in which to invalidate the cached data
   - cache_type - type of caching.  <code>memory</code>, <code>file</code>, <code>dbm</code>, or <code>memcached</code>.
</p>

<h3>Namespaces</h3>
<p>Namespaces are used to organize groups of components into categories, and also to &quot;import&quot; components from other files so that you don't have to type the full filename of the remote component file.
</p>
<p>If the file <code>components.html</code> defines these two components:
</p>
<pre><code># components.html
&lt;%component name=&quot;comp1&quot;&gt;
    this is comp1
&lt;/%component&gt;

&lt;%component name=&quot;comp2&quot;&gt;
    this is comp2
&lt;/%component&gt;
</code></pre><p>You can make another file, for example <code>index.html</code>, that pulls those two components into a namespace called <code>comp</code>:
</p>
<pre><code># index.html
&lt;%namespace name=&quot;comp&quot; file=&quot;components.html&quot;/&gt;

Heres comp1:  ${comp.comp1()}
Heres comp2:  ${comp.comp2()}
</code></pre><p>The <code>&lt;%namespace&gt;</code> tag is more powerful than that.  You can also declare <code>&lt;%components&gt;</code> within the namespace:
</p>
<pre><code># define a namespace
&lt;%namespace name=&quot;stuff&quot;&gt;
    &lt;%component name=&quot;comp1&quot;&gt;
        comp1
    &lt;/%component&gt;
&lt;/%namespace&gt;

# then call it
${stuff:comp1()}
</code></pre><p>Namespaces can also import modules containing regular Python callables.  These callables need to take at least one argument, <code>context</code>:
</p>
<p>A module file <code>some/module.py</code> might contain the callable:
</p>
<pre><code>def my_tag(context):
    context.write(&quot;hello world&quot;)
</code></pre><p>A template can use this module via:
</p>
<pre><code>&lt;%namespace name=&quot;hw&quot; module=&quot;some.module&quot;/&gt;

${hw.my_tag()}
</code></pre><p>Note that the <code>context</code> argument is not needed in the call; the <code>namespace</code> tag creates a locally-scoped callable which takes care of it.
</p>
</body>

</html>



